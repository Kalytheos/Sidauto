// Variables globales
let allBooks = [];
let filteredBooks = [];
let suggestionsVisible = false;

// Variables de paginaci√≥n
let currentPage = 1;
let itemsPerPage = 20;
let totalPages = 1;

// Cargar libros desde el archivo JSON actualizado
async function loadBooksFromJSON() {
  try {
    console.log('‚úÖ Cargando libros desde JSON actualizado...');
    
    const response = await fetch('./data/libros.json');
    
    if (!response.ok) {
      throw new Error(`Error HTTP: ${response.status}`);
    }
    
    const rawData = await response.json();
    console.log('üìö Datos cargados desde JSON:', `${rawData.length} registros`);
    
    // Transformar los datos del nuevo formato al formato esperado
    allBooks = rawData.map((item, index) => ({
      id: `LIB${String(item.No).padStart(3, '0')}`,
      titulo: item['TITULO\n245$A'] || 'Sin t√≠tulo',
      autor: item['AUTOR\n1XX'] || 'Autor desconocido',
      isbn: item['ISBN\n020$A'] || '',
      editorial: item['EDITORIAL \n264$B'] || 'Editorial desconocida',
      a√±o: parseInt(item['A√ëO DE PUBLICACI√ìN']) || 0,
      genero: item['MATERIA'] || 'Sin clasificar',
      categoria: item['MATERIA'] || 'General',
      ubicacion: item['UBICACI√ìN '] || 'No especificada',
      codigo: item['C√ìDIGO'] || '',
      estado: 'disponible', // Por defecto disponible
      descripcion: `Libro de ${item['MATERIA'] || 'literatura'} publicado en ${item['A√ëO DE PUBLICACI√ìN'] || 'fecha desconocida'}.`,
      fechaAdquisicion: item['FECHA DE ADQUISICI√ìN '] || '',
      edicion: item['No. EDICION\n'] || '1era',
      cantidad: item['CANTIDAD '] || '1',
      tags: [
        item['MATERIA']?.toLowerCase(),
        item['AUTOR\n1XX']?.split(' ')[0]?.toLowerCase(),
        item['A√ëO DE PUBLICACI√ìN']
      ].filter(Boolean)
    }));
    
    console.log(`‚úÖ Se transformaron ${allBooks.length} libros exitosamente`);
    
    // Mostrar mensaje de bienvenida por defecto
    displayBooks([]);
    
    // Mostrar mensaje de bienvenida en contador
    updateSearchResults(0, 'welcome');
    
    // Actualizar estad√≠sticas
    updateBookStatistics();
    
    // Poblar filtros con las nuevas categor√≠as
    populateFiltersFromBooks();
    
    console.log('üìö Libros disponibles:', allBooks.slice(0, 5).map(book => book.titulo));
    console.log(`üìä Total de libros: ${allBooks.length}`);
    
  } catch (error) {
    console.error('‚ùå Error al cargar libros:', error);
    loadFallbackBooks();
  }
}

// Datos de fallback (simplificados para debug)
// Datos de fallback (mensaje de error si JSON no carga)
function loadFallbackBooks() {
  console.log('üîÑ Usando datos de fallback');
  
  allBooks = [
    {
      id: 'FALL001',
      titulo: 'Error de Carga - JSON no disponible',
      autor: 'Sistema SIDAUTO',
      isbn: '',
      editorial: 'Sistema',
      a√±o: 2025,
      genero: 'Sistema',
      categoria: 'Error',
      ubicacion: 'N/A',
      codigo: 'ERROR001',
      estado: 'error',
      descripcion: 'No se pudo cargar la base de datos de libros. Verifica que el archivo data/libros.json est√© disponible.',
      fechaAdquisicion: '',
      edicion: '1era',
      cantidad: '0',
      tags: ['error', 'sistema', 'json']
    }
  ];
  
  filteredBooks = [];
  displayBooks([]);
  updateBookStatistics();
  updateSearchResults(0, 'error');
}

// Poblar selectores de filtros desde los libros cargados
function populateFiltersFromBooks() {
  const genreSelect = document.getElementById('genreFilter');
  const editorialSelect = document.getElementById('editorialFilter');
  const yearSelect = document.getElementById('yearFilter');
  
  if (!genreSelect || !editorialSelect || !yearSelect) {
    console.log('‚ö†Ô∏è Algunos selectores de filtros no encontrados');
    return;
  }
  
  // Limpiar opciones existentes (excepto la primera "Todos")
  [genreSelect, editorialSelect, yearSelect].forEach(select => {
    while (select.children.length > 1) {
      select.removeChild(select.lastChild);
    }
  });
  
  if (!allBooks || allBooks.length === 0) return;
  
  // Obtener valores √∫nicos de los libros
  const generos = [...new Set(allBooks.map(libro => libro.genero).filter(Boolean))].sort();
  const editoriales = [...new Set(allBooks.map(libro => libro.editorial).filter(Boolean))].sort();
  const a√±os = [...new Set(allBooks.map(libro => libro.a√±o).filter(a√±o => a√±o && a√±o > 0))].sort((a, b) => b - a);
  
  // Poblar g√©neros
  generos.forEach(genero => {
    const option = document.createElement('option');
    option.value = genero;
    option.textContent = genero;
    genreSelect.appendChild(option);
  });
  
  // Poblar editoriales
  editoriales.forEach(editorial => {
    const option = document.createElement('option');
    option.value = editorial;
    option.textContent = editorial;
    editorialSelect.appendChild(option);
  });
  
  // Poblar a√±os
  a√±os.forEach(a√±o => {
    const option = document.createElement('option');
    option.value = a√±o;
    option.textContent = a√±o;
    yearSelect.appendChild(option);
  });
  
  console.log(`‚úÖ Filtros poblados: ${generos.length} g√©neros, ${editoriales.length} editoriales, ${a√±os.length} a√±os`);
}

// Crear tarjeta de libro actualizada para la nueva estructura
function createBookCard(libro) {
  const estadoClass = libro.estado || 'disponible';
  const estadoTexto = {
    'disponible': '‚úÖ Disponible',
    'prestado': 'üì§ Prestado',
    'reservado': 'üìã Reservado',
    'sistema': '‚öôÔ∏è Sistema',
    'error': '‚ùå Error'
  }[estadoClass] || '‚úÖ Disponible';
  
  // Crear icono basado en el g√©nero/materia
  const genreIcon = {
    'LITERATURA': 'üìö',
    'FICCI√ìN': 'üìñ',
    'HISTORIA': 'üèõÔ∏è',
    'CIENCIAS': 'üî¨',
    'ARTE': 'üé®',
    'FILOSOF√çA': 'üí≠',
    'DERECHO': '‚öñÔ∏è',
    'MEDICINA': 'üè•',
    'MATEM√ÅTICAS': '‚ûï',
    'INGENIER√çA': '‚öôÔ∏è',
    'ECONOM√çA': 'üíº',
    'PSICOLOG√çA': 'üß†',
    'EDUCACI√ìN': 'üéì',
    'RELIGI√ìN': '‚úùÔ∏è',
    'DEPORTES': '‚öΩ',
    'COCINA': 'üç≥',
    'VIAJES': '‚úàÔ∏è',
    'BIOGRAF√çA': 'üë§',
    'AUTOAYUDA': 'üí™',
    'NOVELA': 'üìò',
    'CUENTO': 'ÔøΩ',
    'POES√çA': 'üé≠',
    'ENSAYO': 'üìù',
    'TEATRO': 'üé™'
  }[libro.genero?.toUpperCase()] || 'üìö';

  // Limpiar y formatear datos
  const titulo = (libro.titulo || 'Sin t√≠tulo').replace(/\n/g, ' ').trim();
  const autor = (libro.autor || 'Autor desconocido').replace(/\n/g, ' ').trim();
  const editorial = (libro.editorial || 'Editorial desconocida').replace(/\n/g, ' ').trim();
  const a√±o = libro.a√±o && libro.a√±o > 0 ? libro.a√±o : 'N/D';
  const genero = (libro.genero || 'Sin clasificar').replace(/\n/g, ' ').trim();
  const ubicacion = (libro.ubicacion || 'No especificada').replace(/\n/g, ' ').trim();
  const codigo = (libro.codigo || libro.id || 'N/A').replace(/\n/g, ' ').trim();

  return `
    <div class="book-card" onclick="openBookDetails('${libro.id}')">
      <div class="book-header">
        <div class="book-icon">${genreIcon}</div>
        <div class="book-id">${codigo}</div>
      </div>
      
      <div class="book-info">
        <div class="book-content">
          <h3 class="book-title">${titulo}</h3>
          <p class="book-author">por ${autor}</p>
          <p class="book-description">${libro.descripcion || `Libro de ${genero.toLowerCase()} disponible en ${ubicacion}`}</p>
        </div>
        
        <div class="book-footer">
          <div class="book-details">
            <div class="detail-row">
              <span class="detail-label">üìè Editorial:</span>
              <span>${editorial}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">üìÖ A√±o:</span>
              <span>${a√±o}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">üìÇ Materia:</span>
              <span>${genero}</span>
            </div>
            <div class="detail-row">
              <span class="detail-label">üìç Ubicaci√≥n:</span>
              <span>${ubicacion}</span>
            </div>
            ${libro.isbn ? `
            <div class="detail-row">
              <span class="detail-label">üîç ISBN:</span>
              <span>${libro.isbn}</span>
            </div>` : ''}
          </div>
          
          <div class="book-status ${estadoClass}">${estadoTexto}</div>
        </div>
      </div>
    </div>
  `;
}

// Mostrar libros con paginaci√≥n
function displayBooks(books) {
  const booksGrid = document.getElementById('booksGrid');
  const paginationContainer = document.getElementById('paginationContainer');
  
  if (!booksGrid) return;
  
  // Actualizar filteredBooks globalmente
  filteredBooks = books;
  
  if (books.length === 0) {
    // Ocultar paginaci√≥n cuando no hay resultados
    if (paginationContainer) {
      paginationContainer.style.display = 'none';
    }
    
    // Verificar si es estado inicial o no hay resultados
    const searchInput = document.getElementById('searchInput');
    const quickSearchInput = document.getElementById('quickSearchInput');
    const hasSearch = (searchInput && searchInput.value.trim()) || 
                     (quickSearchInput && quickSearchInput.value.trim());
    
    if (!hasSearch) {
      // Estado inicial - mostrar mensaje de bienvenida
      booksGrid.innerHTML = `
        <div class="welcome-message">
          <div class="welcome-icon">üìö</div>
          <h3>Bienvenido a SIDAUTO BIBLIOTECA</h3>
          <p>Utiliza la barra de b√∫squeda para encontrar libros en nuestra colecci√≥n</p>
          <div class="search-suggestions">
            <p><strong>Puedes buscar por:</strong></p>
            <div class="suggestion-tags">
              <span class="suggestion-tag">T√≠tulo</span>
              <span class="suggestion-tag">Autor</span>
              <span class="suggestion-tag">G√©nero</span>
              <span class="suggestion-tag">Editorial</span>
            </div>
          </div>
        </div>
      `;
    } else {
      // No hay resultados de b√∫squeda
      booksGrid.innerHTML = `
        <div class="no-results">
          <h3>üìö No se encontraron libros</h3>
          <p>Intenta con otros t√©rminos de b√∫squeda</p>
        </div>
      `;
    }
    return;
  }
  
  // Calcular paginaci√≥n
  totalPages = Math.ceil(books.length / itemsPerPage);
  
  // Ajustar p√°gina actual si est√° fuera de rango
  if (currentPage > totalPages) {
    currentPage = totalPages;
  }
  if (currentPage < 1) {
    currentPage = 1;
  }
  
  // Calcular √≠ndices para la p√°gina actual
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = Math.min(startIndex + itemsPerPage, books.length);
  
  // Obtener libros para la p√°gina actual
  const booksForCurrentPage = books.slice(startIndex, endIndex);
  
  // Mostrar los libros
  const booksHTML = booksForCurrentPage.map(book => createBookCard(book)).join('');
  booksGrid.innerHTML = booksHTML;
  
  // Mostrar y actualizar controles de paginaci√≥n
  updatePaginationControls();
  
  // Scroll suave hacia arriba cuando se cambia de p√°gina (solo si no es la primera carga)
  if (books.length > itemsPerPage && currentPage > 1) {
    const bibliotecaSection = document.getElementById('biblioteca');
    if (bibliotecaSection) {
      bibliotecaSection.scrollIntoView({ 
        behavior: 'smooth',
        block: 'start'
      });
    }
  }
}

// Actualizar controles de paginaci√≥n
function updatePaginationControls() {
  const paginationContainer = document.getElementById('paginationContainer');
  const paginationInfo = document.getElementById('paginationInfo');
  const pageNumbers = document.getElementById('pageNumbers');
  const prevBtn = document.getElementById('prevPage');
  const nextBtn = document.getElementById('nextPage');
  const firstBtn = document.getElementById('firstPage');
  const lastBtn = document.getElementById('lastPage');
  
  if (!paginationContainer || !filteredBooks || filteredBooks.length === 0) {
    if (paginationContainer) paginationContainer.style.display = 'none';
    return;
  }
  
  // Mostrar contenedor de paginaci√≥n
  paginationContainer.style.display = 'flex';
  
  // Actualizar informaci√≥n de paginaci√≥n
  const startItem = ((currentPage - 1) * itemsPerPage) + 1;
  const endItem = Math.min(currentPage * itemsPerPage, filteredBooks.length);
  
  if (paginationInfo) {
    paginationInfo.textContent = `Mostrando ${startItem}-${endItem} de ${filteredBooks.length} libros`;
  }
  
  // Actualizar botones de navegaci√≥n
  if (prevBtn && firstBtn) {
    const isFirstPage = currentPage === 1;
    prevBtn.disabled = isFirstPage;
    firstBtn.disabled = isFirstPage;
  }
  
  if (nextBtn && lastBtn) {
    const isLastPage = currentPage === totalPages;
    nextBtn.disabled = isLastPage;
    lastBtn.disabled = isLastPage;
  }
  
  // Generar n√∫meros de p√°gina
  if (pageNumbers) {
    pageNumbers.innerHTML = generatePageNumbers();
  }
}

// Generar n√∫meros de p√°gina con l√≥gica de "..." 
function generatePageNumbers() {
  let pagesHTML = '';
  const maxVisiblePages = 7; // N√∫mero m√°ximo de p√°ginas visibles
  
  if (totalPages <= maxVisiblePages) {
    // Mostrar todas las p√°ginas si son pocas
    for (let i = 1; i <= totalPages; i++) {
      pagesHTML += `
        <button class="page-number ${i === currentPage ? 'active' : ''}" 
                onclick="goToPage(${i})">${i}</button>
      `;
    }
  } else {
    // L√≥gica compleja para muchas p√°ginas
    const startPage = Math.max(1, currentPage - 2);
    const endPage = Math.min(totalPages, currentPage + 2);
    
    // Primera p√°gina
    if (startPage > 1) {
      pagesHTML += `<button class="page-number ${currentPage === 1 ? 'active' : ''}" onclick="goToPage(1)">1</button>`;
      if (startPage > 2) {
        pagesHTML += `<span class="page-ellipsis">...</span>`;
      }
    }
    
    // P√°ginas del rango actual
    for (let i = startPage; i <= endPage; i++) {
      pagesHTML += `
        <button class="page-number ${i === currentPage ? 'active' : ''}" 
                onclick="goToPage(${i})">${i}</button>
      `;
    }
    
    // √öltima p√°gina
    if (endPage < totalPages) {
      if (endPage < totalPages - 1) {
        pagesHTML += `<span class="page-ellipsis">...</span>`;
      }
      pagesHTML += `<button class="page-number ${currentPage === totalPages ? 'active' : ''}" onclick="goToPage(${totalPages})">${totalPages}</button>`;
    }
  }
  
  return pagesHTML;
}

// Funciones de navegaci√≥n de p√°gina
function goToPage(page) {
  if (page >= 1 && page <= totalPages && page !== currentPage) {
    currentPage = page;
    displayBooks(filteredBooks);
  }
}

function goToFirstPage() {
  goToPage(1);
}

function goToLastPage() {
  goToPage(totalPages);
}

function goToPrevPage() {
  if (currentPage > 1) {
    goToPage(currentPage - 1);
  }
}

function goToNextPage() {
  if (currentPage < totalPages) {
    goToPage(currentPage + 1);
  }
}

// Cambiar n√∫mero de elementos por p√°gina
function changeItemsPerPage(newItemsPerPage) {
  itemsPerPage = parseInt(newItemsPerPage);
  currentPage = 1; // Resetear a primera p√°gina
  displayBooks(filteredBooks);
}

// Actualizar contador de resultados con informaci√≥n de paginaci√≥n
function updateSearchResults(count, state = 'search') {
  const resultsSpan = document.getElementById('searchResults');
  if (!resultsSpan) return;
  
  switch (state) {
    case 'welcome':
      // Estado inicial - mensaje de bienvenida
      resultsSpan.innerHTML = `Utiliza la b√∫squeda para explorar nuestra colecci√≥n`;
      break;
    case 'search':
      // Resultados de b√∫squeda con informaci√≥n de paginaci√≥n
      if (count > itemsPerPage) {
        resultsSpan.innerHTML = `Encontrados <strong>${count}</strong> ${count === 1 ? 'libro' : 'libros'} - P√°gina ${currentPage} de ${totalPages}`;
      } else {
        resultsSpan.innerHTML = `Mostrando <strong>${count}</strong> ${count === 1 ? 'libro' : 'libros'}`;
      }
      break;
    case 'no-results':
      // Sin resultados
      resultsSpan.innerHTML = `No se encontraron libros con esos criterios`;
      break;
    case 'total':
      // Mostrar todos los libros (cuando se hace "limpiar filtros")
      if (count > itemsPerPage) {
        resultsSpan.innerHTML = `<strong>${count}</strong> libros en total - P√°gina ${currentPage} de ${totalPages}`;
      } else {
        resultsSpan.innerHTML = `Mostrando <strong>${count}</strong> ${count === 1 ? 'libro' : 'libros'} de nuestra colecci√≥n`;
      }
      break;
    case 'error':
      // Error de carga
      resultsSpan.innerHTML = `‚ö†Ô∏è Error al cargar la biblioteca`;
      break;
    default:
      resultsSpan.innerHTML = `Mostrando <strong>${count}</strong> ${count === 1 ? 'libro' : 'libros'}`;
  }
}

// Sistema de b√∫squeda y filtros
function initSearchSystem() {
  const searchInput = document.getElementById('searchInput');
  const clearBtn = document.getElementById('clearSearch');
  const genreFilter = document.getElementById('genreFilter');
  const editorialFilter = document.getElementById('editorialFilter');
  const yearFilter = document.getElementById('yearFilter');
  const statusFilter = document.getElementById('statusFilter');
  const resetBtn = document.getElementById('resetFilters');
  
  if (!searchInput) return; // Si no existe el elemento, salir
  
  // B√∫squeda en tiempo real
  searchInput.addEventListener('input', function() {
    const query = this.value.toLowerCase();
    if (clearBtn) {
      clearBtn.classList.toggle('visible', query.length > 0);
    }
    
    // Sincronizar con b√∫squeda r√°pida
    const quickSearchInput = document.getElementById('quickSearchInput');
    if (quickSearchInput && quickSearchInput.value !== query) {
      quickSearchInput.value = query;
    }
    
    applyFilters();
  });
  
  // Bot√≥n limpiar b√∫squeda
  if (clearBtn) {
    clearBtn.addEventListener('click', function() {
      searchInput.value = '';
      this.classList.remove('visible');
      
      // Limpiar tambi√©n b√∫squeda r√°pida
      const quickSearchInput = document.getElementById('quickSearchInput');
      if (quickSearchInput) {
        quickSearchInput.value = '';
      }
      
      applyFilters();
    });
  }
  
  // Filtros
  [genreFilter, editorialFilter, yearFilter, statusFilter].forEach(filter => {
    if (filter) {
      filter.addEventListener('change', applyFilters);
    }
  });
  
  // Bot√≥n reset
  if (resetBtn) {
    resetBtn.addEventListener('click', function() {
      searchInput.value = '';
      if (genreFilter) genreFilter.value = '';
      if (editorialFilter) editorialFilter.value = '';
      if (yearFilter) yearFilter.value = '';
      if (statusFilter) statusFilter.value = '';
      if (clearBtn) clearBtn.classList.remove('visible');
      
      // Limpiar tambi√©n b√∫squeda r√°pida
      const quickSearchInput = document.getElementById('quickSearchInput');
      if (quickSearchInput) {
        quickSearchInput.value = '';
      }
      
      // Resetear paginaci√≥n
      currentPage = 1;
      
      applyFilters();
    });
  }
}

// Aplicar filtros de b√∫squeda (actualizado para nueva estructura)
function applyFilters() {
  const query = document.getElementById('searchInput').value.toLowerCase().trim();
  const selectedGenre = document.getElementById('genreFilter').value;
  const selectedEditorial = document.getElementById('editorialFilter').value;
  const selectedYear = document.getElementById('yearFilter').value;
  const selectedStatus = document.getElementById('statusFilter').value;
  
  filteredBooks = allBooks.filter(libro => {
    // Funci√≥n helper para limpiar y buscar en texto
    const searchInText = (text) => {
      if (!text) return false;
      return String(text).toLowerCase().replace(/\n/g, ' ').includes(query);
    };
    
    // B√∫squeda por texto en m√∫ltiples campos
    const matchesSearch = query === '' || 
      searchInText(libro.titulo) ||
      searchInText(libro.autor) ||
      searchInText(libro.editorial) ||
      searchInText(libro.genero) ||
      searchInText(libro.isbn) ||
      searchInText(libro.codigo) ||
      searchInText(libro.ubicacion) ||
      searchInText(libro.categoria) ||
      (libro.tags && libro.tags.some(tag => searchInText(tag))) ||
      (libro.descripcion && searchInText(libro.descripcion));
    
    // Filtro por g√©nero/materia
    const matchesGenre = selectedGenre === '' || libro.genero === selectedGenre;
    
    // Filtro por editorial
    const matchesEditorial = selectedEditorial === '' || libro.editorial === selectedEditorial;
    
    // Filtro por a√±o
    const matchesYear = selectedYear === '' || 
      (libro.a√±o && libro.a√±o.toString() === selectedYear);
    
    // Filtro por estado
    const matchesStatus = selectedStatus === '' || libro.estado === selectedStatus;
    
    return matchesSearch && matchesGenre && matchesEditorial && matchesYear && matchesStatus;
  });
  
  // Resetear paginaci√≥n cuando se aplican filtros
  currentPage = 1;
  
  displayBooks(filteredBooks);
  
  // Determinar el estado del contador basado en los filtros
  const hasActiveFilters = query || selectedGenre || selectedEditorial || selectedYear || selectedStatus;
  
  if (!hasActiveFilters) {
    // No hay filtros activos - estado de bienvenida
    updateSearchResults(0, 'welcome');
  } else if (filteredBooks.length === 0) {
    // Hay filtros pero no resultados
    updateSearchResults(0, 'no-results');
  } else if (filteredBooks.length === allBooks.length && query === '') {
    // Mostrando todos los libros (filtros que incluyen todo)
    updateSearchResults(filteredBooks.length, 'total');
  } else {
    // Mostrando resultados filtrados
    updateSearchResults(filteredBooks.length, 'search');
  }
}

// Actualizar estad√≠sticas de libros
function updateBookStatistics() {
  // Contar libros por estado
  const stats = {
    disponibles: 0,
    prestados: 0,
    reservados: 0,
    total: allBooks.length
  };
  
  allBooks.forEach(libro => {
    if (libro.estado === 'disponible') {
      stats.disponibles++;
    } else if (libro.estado === 'prestado') {
      stats.prestados++;
    } else if (libro.estado === 'reservado') {
      stats.reservados++;
    }
  });
  
  console.log('Estad√≠sticas actualizadas:', stats);
  
  // Actualizar UI si existen los elementos
  const totalBooksElement = document.getElementById('totalBooks');
  const availableBooksElement = document.getElementById('availableBooks');
  
  if (totalBooksElement) {
    totalBooksElement.textContent = stats.total;
  }
  
  if (availableBooksElement) {
    availableBooksElement.textContent = stats.disponibles;
  }
}

// Funci√≥n de b√∫squeda r√°pida tipo Google con sugerencias
function initQuickSearch() {
  const quickSearchInput = document.getElementById('quickSearchInput');
  
  if (!quickSearchInput) return;
  
  // Crear contenedor de sugerencias
  const suggestionsContainer = createSuggestionsContainer();
  quickSearchInput.parentNode.appendChild(suggestionsContainer);
  
  // B√∫squeda con sugerencias (independiente)
  quickSearchInput.addEventListener('input', function() {
    const query = this.value.toLowerCase().trim();
    
    if (query.length > 0) {
      showSuggestions(query, suggestionsContainer);
    } else {
      hideSuggestions(suggestionsContainer);
    }
  });
  
  // Navegaci√≥n con teclado
  quickSearchInput.addEventListener('keydown', function(e) {
    handleKeyNavigation(e, suggestionsContainer);
  });
  
  // Ocultar sugerencias al perder foco (con delay para permitir clics)
  quickSearchInput.addEventListener('blur', function() {
    setTimeout(() => {
      hideSuggestions(suggestionsContainer);
    }, 150);
  });
  
  // Ocultar sugerencias con ESC
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      hideSuggestions(suggestionsContainer);
      quickSearchInput.blur();
    }
  });
  
  // Al hacer Enter, ejecutar b√∫squeda y ir a la secci√≥n
  quickSearchInput.addEventListener('keypress', function(e) {
    if (e.key === 'Enter') {
      e.preventDefault();
      const query = this.value.trim();
      if (query.length > 0) {
        executeSearch(query);
        hideSuggestions(suggestionsContainer);
      }
    }
  });
}

// Crear contenedor de sugerencias
function createSuggestionsContainer() {
  const container = document.createElement('div');
  container.className = 'search-suggestions-popup';
  container.style.display = 'none';
  return container;
}

// Mostrar sugerencias
function showSuggestions(query, container) {
  const suggestions = generateSuggestions(query);
  
  if (suggestions.length === 0) {
    hideSuggestions(container);
    return;
  }
  
  const suggestionsHTML = suggestions.map((suggestion, index) => `
    <div class="suggestion-item ${index === 0 ? 'selected' : ''}" 
         data-query="${suggestion.query}" 
         data-type="${suggestion.type}">
      <span class="suggestion-icon">${suggestion.icon}</span>
      <div class="suggestion-content">
        <div class="suggestion-text">${suggestion.display}</div>
        <div class="suggestion-type">${suggestion.typeText}</div>
      </div>
    </div>
  `).join('');
  
  container.innerHTML = suggestionsHTML;
  container.style.display = 'block';
  suggestionsVisible = true;
  
  // Agregar event listeners a las sugerencias
  container.querySelectorAll('.suggestion-item').forEach(item => {
    item.addEventListener('click', function() {
      const query = this.dataset.query;
      document.getElementById('quickSearchInput').value = query;
      executeSearch(query);
      hideSuggestions(container);
    });
  });
}

// Generar sugerencias inteligentes
function generateSuggestions(query) {
  const suggestions = [];
  const maxSuggestions = 8;
  const lowerQuery = query.toLowerCase();
  
  // Funci√≥n helper para limpiar texto y buscar
  const cleanAndMatch = (text, query) => {
    if (!text) return false;
    return String(text).toLowerCase().replace(/\n/g, ' ').includes(query);
  };
  
  // Funci√≥n para resaltar coincidencias
  const safeHighlight = (text, query) => {
    if (!text) return '';
    const cleanText = String(text).replace(/\n/g, ' ').trim();
    return highlightMatch(cleanText, query);
  };
  
  // B√∫squeda por t√≠tulo
  allBooks.forEach(book => {
    if (cleanAndMatch(book.titulo, lowerQuery)) {
      suggestions.push({
        query: book.titulo.replace(/\n/g, ' ').trim(),
        display: `<strong>${safeHighlight(book.titulo, lowerQuery)}</strong>`,
        type: 'title',
        typeText: `por ${book.autor ? book.autor.replace(/\n/g, ' ').trim() : 'Autor desconocido'}`,
        icon: 'üìñ'
      });
    }
  });
  
  // B√∫squeda por autor
  const authors = [...new Set(allBooks
    .map(book => book.autor ? book.autor.replace(/\n/g, ' ').trim() : 'Autor desconocido')
    .filter(Boolean)
  )];
  
  authors.forEach(author => {
    if (cleanAndMatch(author, lowerQuery)) {
      const bookCount = allBooks.filter(book => 
        book.autor && cleanAndMatch(book.autor, author.toLowerCase())
      ).length;
      suggestions.push({
        query: author,
        display: `<strong>${safeHighlight(author, lowerQuery)}</strong>`,
        type: 'author',
        typeText: `${bookCount} libro${bookCount > 1 ? 's' : ''}`,
        icon: 'üë§'
      });
    }
  });
  
  // B√∫squeda por materia/g√©nero
  const materias = [...new Set(allBooks
    .map(book => book.genero ? book.genero.replace(/\n/g, ' ').trim() : null)
    .filter(Boolean)
  )];
  
  materias.forEach(materia => {
    if (cleanAndMatch(materia, lowerQuery)) {
      const bookCount = allBooks.filter(book => 
        book.genero && cleanAndMatch(book.genero, materia.toLowerCase())
      ).length;
      suggestions.push({
        query: materia,
        display: `<strong>${safeHighlight(materia, lowerQuery)}</strong>`,
        type: 'subject',
        typeText: `${bookCount} libro${bookCount > 1 ? 's' : ''}`,
        icon: 'üìÇ'
      });
    }
  });
  
  // B√∫squeda por editorial
  const editoriales = [...new Set(allBooks
    .map(book => book.editorial ? book.editorial.replace(/\n/g, ' ').trim() : null)
    .filter(Boolean)
  )];
  
  editoriales.forEach(editorial => {
    if (cleanAndMatch(editorial, lowerQuery)) {
      const bookCount = allBooks.filter(book => 
        book.editorial && cleanAndMatch(book.editorial, editorial.toLowerCase())
      ).length;
      suggestions.push({
        query: editorial,
        display: `<strong>${safeHighlight(editorial, lowerQuery)}</strong>`,
        type: 'publisher',
        typeText: `${bookCount} libro${bookCount > 1 ? 's' : ''}`,
        icon: 'üè¢'
      });
    }
  });
  
  // B√∫squeda por c√≥digo/ISBN
  allBooks.forEach(book => {
    if ((book.codigo && cleanAndMatch(book.codigo, lowerQuery)) || 
        (book.isbn && cleanAndMatch(book.isbn, lowerQuery))) {
      suggestions.push({
        query: book.codigo || book.isbn || book.id,
        display: `<strong>${safeHighlight(book.codigo || book.isbn || book.id, lowerQuery)}</strong>`,
        type: 'code',
        typeText: `${book.titulo ? book.titulo.replace(/\n/g, ' ').trim().substring(0, 30) + '...' : 'Sin t√≠tulo'}`,
        icon: 'ÔøΩ'
      });
    }
  });
  
  // Limitar n√∫mero de sugerencias y remover duplicados
  return suggestions
    .filter((suggestion, index, self) => 
      index === self.findIndex(s => s.query === suggestion.query)
    )
    .slice(0, maxSuggestions);
}

// Resaltar coincidencias
function highlightMatch(text, query) {
  const regex = new RegExp(`(${query})`, 'gi');
  return text.replace(regex, '<mark>$1</mark>');
}

// Ocultar sugerencias
function hideSuggestions(container) {
  container.style.display = 'none';
  suggestionsVisible = false;
}

// Ejecutar b√∫squeda y navegar a la secci√≥n
function executeSearch(query) {
  // Scroll a la secci√≥n biblioteca
  const bibliotecaSection = document.getElementById('biblioteca');
  if (bibliotecaSection) {
    bibliotecaSection.scrollIntoView({ 
      behavior: 'smooth',
      block: 'start'
    });
  }
  
  // Aplicar b√∫squeda en la secci√≥n principal
  setTimeout(() => {
    const mainSearchInput = document.getElementById('searchInput');
    if (mainSearchInput) {
      mainSearchInput.value = query;
      applyFilters();
    }
  }, 500);
}

// Navegaci√≥n con teclado en sugerencias
function handleKeyNavigation(e, container) {
  if (!suggestionsVisible) return;
  
  const items = container.querySelectorAll('.suggestion-item');
  const selected = container.querySelector('.suggestion-item.selected');
  
  if (e.key === 'ArrowDown') {
    e.preventDefault();
    const next = selected?.nextElementSibling || items[0];
    updateSelection(selected, next);
  } else if (e.key === 'ArrowUp') {
    e.preventDefault();
    const prev = selected?.previousElementSibling || items[items.length - 1];
    updateSelection(selected, prev);
  } else if (e.key === 'Enter' && selected) {
    e.preventDefault();
    const query = selected.dataset.query;
    document.getElementById('quickSearchInput').value = query;
    executeSearch(query);
    hideSuggestions(container);
  }
}

// Actualizar selecci√≥n en sugerencias
function updateSelection(current, next) {
  if (current) current.classList.remove('selected');
  if (next) next.classList.add('selected');
}

// Funci√≥n para mostrar detalles del libro (actualizada)
function openBookDetails(bookId) {
  const libro = allBooks.find(book => book.id === bookId);
  
  if (!libro) {
    alert('‚ùå No se encontraron detalles para este libro.');
    return;
  }
  
  const detalles = `
üìö DETALLES DEL LIBRO

üìñ T√≠tulo: ${libro.titulo || 'Sin t√≠tulo'}
üë§ Autor: ${libro.autor || 'Autor desconocido'}
üè¢ Editorial: ${libro.editorial || 'Editorial desconocida'}
üìÖ A√±o: ${libro.a√±o && libro.a√±o > 0 ? libro.a√±o : 'No especificado'}
üìÇ Materia: ${libro.genero || 'Sin clasificar'}
üìç Ubicaci√≥n: ${libro.ubicacion || 'No especificada'}
üîç C√≥digo: ${libro.codigo || libro.id || 'N/A'}
${libro.isbn ? `üìö ISBN: ${libro.isbn}` : ''}
${libro.edicion ? `üìÑ Edici√≥n: ${libro.edicion}` : ''}
${libro.cantidad ? `üìä Cantidad: ${libro.cantidad}` : ''}

üìù Descripci√≥n: ${libro.descripcion || 'Sin descripci√≥n disponible'}

üéØ Estado: ${libro.estado === 'disponible' ? '‚úÖ Disponible' : 
             libro.estado === 'prestado' ? 'üì§ Prestado' : 
             libro.estado === 'reservado' ? 'üìã Reservado' : '‚ùì No definido'}

${libro.fechaAdquisicion ? `üìÜ Fecha de adquisici√≥n: ${libro.fechaAdquisicion}` : ''}

¬°Pr√≥ximamente m√°s funcionalidades!
  `.trim();
  
  alert(detalles);
}

// Navegaci√≥n suave
function initSmoothScroll() {
  const links = document.querySelectorAll('a[href^="#"]');
  
  links.forEach(link => {
    link.addEventListener('click', function(e) {
      e.preventDefault();
      
      const targetId = this.getAttribute('href');
      const targetElement = document.querySelector(targetId);
      
      if (targetElement) {
        const offsetTop = targetElement.offsetTop - 70; // Altura del navbar
        
        window.scrollTo({
          top: offsetTop,
          behavior: 'smooth'
        });
      }
    });
  });
}

// Funci√≥n para manejar la vista previa de Planner5D
function setupPlanner5DPreview() {
  const previewImage = document.querySelector('.preview-image');
  
  if (previewImage) {
    previewImage.addEventListener('click', function() {
      // Abrir el enlace en una nueva ventana
      window.open('https://planner5d.onelink.me/stDT/lfqcl8l2', '_blank');
      
      // Analytics o tracking (opcional)
      console.log('Usuario abri√≥ el recorrido virtual de Planner5D');
    });
  }
}

// Inicializar controles de paginaci√≥n
function initPaginationControls() {
  // Event listeners para botones de navegaci√≥n
  const prevBtn = document.getElementById('prevPage');
  const nextBtn = document.getElementById('nextPage');
  const firstBtn = document.getElementById('firstPage');
  const lastBtn = document.getElementById('lastPage');
  const itemsSelect = document.getElementById('itemsPerPage');
  
  if (prevBtn) {
    prevBtn.addEventListener('click', goToPrevPage);
  }
  
  if (nextBtn) {
    nextBtn.addEventListener('click', goToNextPage);
  }
  
  if (firstBtn) {
    firstBtn.addEventListener('click', goToFirstPage);
  }
  
  if (lastBtn) {
    lastBtn.addEventListener('click', goToLastPage);
  }
  
  if (itemsSelect) {
    itemsSelect.addEventListener('change', function() {
      changeItemsPerPage(this.value);
    });
  }
  
  // Navegaci√≥n con teclado (flechas izquierda/derecha para cambiar p√°ginas)
  document.addEventListener('keydown', function(e) {
    // Solo si no estamos escribiendo en un input
    if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') {
      return;
    }
    
    if (e.key === 'ArrowLeft' && currentPage > 1) {
      e.preventDefault();
      goToPrevPage();
    } else if (e.key === 'ArrowRight' && currentPage < totalPages) {
      e.preventDefault();
      goToNextPage();
    }
  });
}

// Inicializaci√≥n cuando el DOM est√© listo
document.addEventListener('DOMContentLoaded', function() {
  // Cargar libros desde JSON
  loadBooksFromJSON();
  
  // Inicializar sistema de b√∫squeda
  initSearchSystem();
  
  // Inicializar b√∫squeda r√°pida del navbar
  initQuickSearch();
  
  // Inicializar controles de paginaci√≥n
  initPaginationControls();
  
  // Otras funcionalidades
  initSmoothScroll();
  setupPlanner5DPreview();
  
  // Agregar efectos de scroll para el navbar
  window.addEventListener('scroll', function() {
    const navbar = document.querySelector('.navbar');
    if (window.scrollY > 100) {
      navbar.style.background = 'rgba(44, 62, 80, 0.95)';
      navbar.style.backdropFilter = 'blur(10px)';
    } else {
      navbar.style.background = 'linear-gradient(135deg, #2c3e50 0%, #34495e 100%)';
      navbar.style.backdropFilter = 'none';
    }
  });
});

// Funci√≥n para intentar cargar libros desde Open Library API (opcional)
async function loadBooksFromAPI() {
  try {
    const response = await fetch('https://openlibrary.org/subjects/fiction.json?limit=6');
    const data = await response.json();
    
    if (data.works && data.works.length > 0) {
      const apiBooks = data.works.map(work => ({
        title: work.title,
        author: work.authors && work.authors.length > 0 ? work.authors[0].name : 'Autor desconocido',
        description: work.first_sentence ? work.first_sentence.join(' ') : 'Descripci√≥n no disponible.',
        cover: work.cover_id ? `https://covers.openlibrary.org/b/id/${work.cover_id}-M.jpg` : null
      }));
      
      return apiBooks;
    }
  } catch (error) {
    console.log('No se pudieron cargar libros de la API, usando datos locales:', error);
  }
  
  return booksData; // Fallback a datos locales
}

// Puedes descomentar esta l√≠nea si quieres probar la API
// loadBooksFromAPI().then(books => console.log('Libros cargados:', books));
